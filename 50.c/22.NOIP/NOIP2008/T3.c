/*
描述
小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个m行n列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标(1,1)，小轩坐在矩阵的右下角，坐标(m,n)。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。
在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。
还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用0表示），可以用一个0-100的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这两条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的两条路径。

格式
输入格式
输入第一行有2个用空格隔开的整数m和n，表示班里有m行n列（1<=m,n<=50）。
接下来的m行是一个m*n的矩阵，矩阵中第i行j列的整数表示坐在第i行j列的学生的好心程度。每行的n个整数之间用空格隔开。

输出格式
输出共一行，包含一个整数，表示来回两条路上参与传递纸条的学生的好心程度之和的最大值。

样例1
样例输入1
3 3
0 3 9
2 8 5
5 7 0

样例输出1
34

限制
各个测试点1s

数据范围
30%的数据满足：1<=m,n<=10
100%的数据满足：1<=m,n<=50

来源
NOIp2008 提高组第三题
*/

/*
  得分：90
  解题报告：
    说实话幸亏数据没那么严格，不然我错的就不止一个点了。。。
    首先，任何形式的贪心是一定错误的 XD，其次，暴搜对于n>=10,m>=10的数据就已经TLE了。
    因此想到动规。
    想到“从起点到终点再回到起点”其实等价于从起点到终点的两条不重叠的路径，因此可以：
      令 f(x1,y1,x2,y2) 表示从起点(0,0)开始，走相同的步数，路线1走到了(x1,y1)、路线2走到了(x2,y2)的最优解。
      根据(x1,y1)和(x2,y2)三种不同的状态，得：
      1.(x1,y1)和(x2,y2)，以及这两点向左、上两方向扩展出的区域没有重叠（实现时先判断情况2和3，这种放在else里）
        f(x1,y1,x2,y2) = max{ f(x1,y1-1,x2,y2-1),
                              f(x1,y1-1,x2-1,y2),
                              f(x1-1,y1,x2,y2-1),
                              f(x1-1,y1,x2-1,y2) } + a[x1][y1] + a[x2][y2]
      2.x1=x2+1

          +---+                
          |   |
      +---+---+
      |   | 2 |
  +---+---+---+
  |   | 1 |
  +---+---+

        f(x1,y1,x2,y2) = max{ f(x1,y1-1,x2,y2-1),
                              f(x1,y1-1,x2-1,y2),
                              f(x1-1,y1,x2-1,y2) } + a[x1][y1] + a[x2][y2]
      3.x2=x1+1

          +---+                
          |   |
      +---+---+
      |   | 1 |
  +---+---+---+
  |   | 2 |
  +---+---+

        f(x1,y1,x2,y2) = max{ f(x1,y1-1,x2,y2-1),
                              f(x1-1,y1,x2,y2-1),
                              f(x1-1,y1,x2-1,y2) } + a[x1][y1] + a[x2][y2]
    因为两条路径的步数是相同的，就可以依据(x1,y1)算出步数，再依据x2算出y2（类似于洛谷模拟赛中“回文路径”一题）
    那么空间复杂度就由O(n^4)降到了O(n^3)，时间复杂度不变（其实我不知道是多少 XD）
    可以使用记忆化搜索，也可以使用递推，还可以使用滚动数组优化。
    另：在记忆化搜索中，判断条件一定要加上 y2>=0 （即x2<=x1+y1）。
*/

//TODO: 改成递推形式、滚动数组优化

#include<iostream>
#include<cstdio>
#include<cstring>
using namespace std;

const int MAX=54;
int check[MAX][MAX][MAX];
int G[MAX][MAX];

int f(int x1, int y1, int x2);
inline int y2(int x1, int y1, int x2);

int main(void){
  memset(check,-1,sizeof(check)); check[0][0][0]=0;
  int n,m; scanf("%d%d",&n,&m);
  for(int i=0;i<n;i++) for(int j=0;j<m;j++) scanf("%d",&G[i][j]);
  int ansMax=0;
  ansMax=max(f(n-1,m-2,n-2),f(n-2,m-1,n-1));
  printf("%d\n",ansMax);

  return 0;
}

int f(int x1, int y1, int x2){
  if(x1<0 || y1<0 || x2<0 || x2>x1+y1) return 0;  //<b> 为保证y2>=0，要始终保证x2<=x1+y1 </b>忘记这个条件，错了一个点
  int & a=check[x1][y1][x2];
  if(a!=-1) return a;
  a=0; int ansMax=0;
  if(x1==x2+1){
    ansMax=max(f(x1,y1-1,x2),max(
               f(x1,y1-1,x2-1),
               f(x1-1,y1,x2-1)));
  }else if(x2==x1+1){
    ansMax=max(f(x1,y1-1,x2),max(
               f(x1-1,y1,x2),
               f(x1-1,y1,x2-1)));
  }else{
    ansMax=max(f(x1,y1-1,x2),max(
               f(x1,y1-1,x2-1),max(
               f(x1-1,y1,x2),
               f(x1-1,y1,x2-1))));
  }
  a=ansMax+G[x1][y1]+G[x2][y2(x1,y1,x2)];
#ifdef DEBUG
  printf("f(%d,%d,%d), aka: (%d,%d)-(%d,%d): %d\n",x1,y1,x2,x1,y1,x2,y2(x1,y1,x2),a);
#endif
  return a;
}
inline int y2(int x1, int y1, int x2){
  return x1+y1-x2;
}
