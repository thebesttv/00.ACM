/*
描述
给你n根火柴棍，你可以拼出多少个形如“A+B=C”的等式？等式中的A、B、C是用火柴棍拼出的整数（若该数非零，则最高位不能是0）。用火柴棍拼数字0-9的拼法如图所示：

  +--+   +  +--+  +--+  +  +  +--+  +--+  +--+  +--+  +--+                                  
  |  |   |     |     |  |  |  |     |        |  |  |  |  |                                  
  +  +   +  +--+  +--+  +--+  +--+  +--+     +  +--+  +--+                                    
  |  |   |  |        |     |     |  |  |     |  |  |     |                                        
  +--+   +  +--+  +--+     +  +--+  +--+     +  +--+  +--+                                          

注意：
1. 加号与等号各自需要两根火柴棍
2. 如果A≠B，则A+B=C与B+A=C视为不同的等式（A、B、C>=0）
3. n根火柴棍必须全部用上

格式
输入格式
输入共一行，有一个整数n（n<=24）。

输出格式
输出共一行，表示能拼成的不同等式的数目。

样例1
样例输入1
14

样例输出1
2

样例2
样例输入2
18

样例输出2
9

限制
1s

输入输出样例1解释
2个等式为0+1=1和1+0=1。

输入输出样例2解释
9个等式为：
0+4=4
0+11=11
1+10=11
2+2=4
2+7=9
4+0=4
7+2=9
10+1=11
11+0=11

来源
NOIP2008提高组第二题。
*/

/*
  得分：100
  解题报告：
    算出最大可能的数字，先预处理0:MAX每个数占用火柴棒的个数，再暴搜即可。
    期待优化。
*/

//TODO: 剪枝优化、尝试动规（不过好像不行的样子）

#include<iostream>
#include<cstdio>
using namespace std;

const int MAX=11111;
int get[10]={6,2,5,5,4,5,6,3,7,6};
int cnt[MAX+10];

inline void init(int n){
  int & a=cnt[n]; //<b></b>
  while(n>0){
    a+=get[n%10];  //不能直接使用cnt[n]，n一直在改变
    n/=10;
  }
}

int main(void){
  cnt[0]=get[0]; for(int i=1;i<=MAX;i++) init(i);
  int n; scanf("%d",&n);
  
  int ans=0;
  for(int i=0;i<=MAX;i++) if(cnt[i]<(n-4)){
    for(int j=0;j<=MAX-i;j++) if(cnt[i]+cnt[j]<(n-4)){
      if(cnt[i]+cnt[j]+cnt[i+j]==n-4) ans++;
    }
  }
  printf("%d\n",ans);

  return 0;
}
