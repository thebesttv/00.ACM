/*
描述
S城现有两座监狱，一共关押着N名罪犯，编号分别为1~N。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为c的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为c的冲突事件。每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到S城Z市长那里。公务繁忙的Z市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。在详细考察了N名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。那么，应如何分配罪犯，才能使Z市长看到的那个冲突事件的影响力最小？这个最小值是多少？

格式
输入格式
输入文件的每行中两个数之间用一个空格隔开。
第一行为两个正整数N和M，分别表示罪犯的数目以及存在仇恨的罪犯对数。
接下来的M行每行为三个正整数aj，bj，cj，表示aj号和bj号罪犯之间存在仇恨，其怨气值为cj。
数据保证1<=aj<=bj<=N,0<=cj<=1000000000,且每对罪犯组合只出现一次。

输出格式
输出文件共1行，为Z市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出0。

样例1
样例输入1
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884

样例输出1
3512

限制
每个测试点1s

样例解释
分配方法：市长看到的冲突事件影响力是3512（由2号和3号罪犯引发）。其他任何分法都不会比这个分法更优。

数据范围
对于 30% 的数据有N≤15。
对于 70% 的数据有N≤2000，M≤50000。
对于 100% 的数据有N≤20000，M≤100000。

来源
noip2010提高组复赛
*/

/*
  得分：100
  解题报告：
    使用并查集维护每个犯人的相对监狱号，贪心地添加。
    因为只关注怒气值最大的事件，只需使最大怒气值最小即可，可以贪心。
    一共有两座监狱，每个犯人在哪个监狱不绝对，只是相对的。
      如 犯人1 和 犯人2 在 1号 监狱，犯人3 在 2号 监狱，也可看作 犯人3 在 1号 监狱，犯人1 和 犯人2 在 2号 监狱。
    而每座监狱又相当于一个犯人的集合，因此想到使用并查集维护。（感觉好像也可以使用二分图，可行吗？）
    因为犯人的监狱号是相对的，类似于“食物链”一题，想到使用两个并查集维护。
    令 p(i) 表示在一座监狱， p(i+n) 表示在另一座监狱，则：
      若 p(a) = p(b) ，则a和b在同一座监狱
      若 p(a) = p(b+n) ，则a和(b+n)在同一座监狱，又b和b+n在不同监狱，即a和b在不同监狱
      其他，则a和b的相对位置不确定
    由此即可以解题。
*/

//能否使用二分图？

//并查集
#include<iostream>
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;

struct Edge{
  int a,b,c;

  bool operator < (const Edge & b) const {
    return c>b.c;
  }
}e[100020];
int p[20020*2];

int getParent(int x){
  return p[x]<0 ? x : p[x]=getParent(p[x]);
}
void merge(int x, int y){
  int px=getParent(x),py=getParent(y);
  if(px==py) return;
  if(p[px]<p[py]){  //|p[px]| > |p[py]|
    p[px]+=p[py];
    p[py]=px;
  }else{
    p[py]+=p[px];
    p[px]=py;
  }
}

int main(void){
  memset(p,-1,sizeof(p));
  int n,m; scanf("%d%d",&n,&m);
  for(int i=0;i<m;i++) scanf("%d%d%d",&e[i].a,&e[i].b,&e[i].c);
  sort(e,e+m);
  int ans=0;
  for(int i=0;i<m;i++){
    int a=e[i].a,b=e[i].b,c=e[i].c;
    if(getParent(a)==getParent(b)) {ans=c; break;}
    else if(getParent(a)==getParent(b+n)) continue;
    else {merge(a,b+n); merge(a+n,b);}
  }
  printf("%d\n",ans);

  return 0;
}
