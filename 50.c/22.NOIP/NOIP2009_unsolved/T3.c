/*
描述
C 国有 n 个大城市和 m 条道路，每条道路连接这 n 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 m 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 1 条。
C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。
商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 n 个城市的标号从 1~ n，阿龙决定从 1 号城市出发，并最终在 n 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 n 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品——水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。
假设 C 国有 5 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

        +---> 2 <----> 3
       /                \
      /                  \
     1                    +---> 5
      \                  /
       \                /
        +-----> 4 <----+

假设 1~n 号城市的水晶球价格分别为 4，3，5，6，1。
阿龙可以选择如下一条线路：1->2->3->5，并在 2 号城市以 3 的价格买入水晶球，在 3 号城市以 5的价格卖出水晶球，赚取的旅费数为 2。
阿龙也可以选择如下一条线路 1->4->5->4->5，并在第 1 次到达 5 号城市时以 1 的价格买入水晶球，在第 2 次到达 4 号城市时以 6 的价格卖出水晶球，赚取的旅费数为 5。
现在给出 n个城市的水晶球价格，m条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

格式
输入格式
第一行包含 2 个正整数 n 和 m，中间用一个空格隔开，分别表示城市的数目和道路的数目。
第二行 n 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 n 个城市的商品价格。
接下来 m行， 每行有 3 个正整数， x， y， z， 每两个整数之间用一个空格隔开。 如果 z=1，表示这条道路是城市 x到城市 y之间的单向道路；如果 z=2，表示这条道路为城市 x 和城市y之间的双向道路。

输出格式
输出共1 行， 包含 1 个整数， 表示最多能赚取的旅费。 如果没有进行贸易，则输出 0。

样例1
样例输入1
5 5
4 3 5 6 1
1 2 1
1 4 1
2 3 2
3 5 1
4 5 2

样例输出1
5

限制
每个测试点1s

数据范围
输入数据保证 1 号城市可以到达n 号城市。
对于 10% 的数据，1≤n≤6。
对于 30% 的数据，1≤n≤100。
对于 50% 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。
对于 100% 的数据，1≤n≤100000，1≤m≤500000，1≤x，y≤n，1≤z≤2，1≤各城市
水晶球价格≤100。

来源
NOIP 2009
*/

/*
  得分：100
  解题报告：
    没有想到这动规竟然对了，好高兴。
    一开始想到搜索，想到从起点bfs一次，再从终点反向bfs一次，找到既能从起点走到该点，又能从该点走到终点的所有点的集合。
    然后将每个可行的点按照价格排序，从价格最大的依次bfs，找互价格最小的且相连通的可行点，但无奈时间复杂度太大，放弃。
    后来突然发现这次考试我还没用动规呢。。。，然后就考虑动规。
    想到用 f(i) 表示到达节点 i 的最优解，但无法确定最大值和最小值，无法写出转移方程，因此考虑换一种方法。
    令 f(i) 表示能够到达节点 i 的点中，价格的最小值。
    令 g(i) 表示 i 能够到达的点中，价格的最大值。
      （为什么是“i能够到达的点”呢，因为如果变成“能够到达i的点”，则不能确定是先到了价格小的还是先到了价格大的，更不知道能不能从价格小的到达价格大的，而使用现在的表示，则一定能确定从价格小的能走到i，从i也能走到价格大的）
    能写出转移方程：
      f(i) = min{ f(j), a[i] }, G[j][i]=1 从起点到i能得到的最小值
      g(i) = max{ g(j), a[i] }, G[i][j]=1 从i到终点能得到的最小值
    这样一来，只要先通过两遍bfs找到可行点，再对每个可行点使用上述两个方程dp即可。
    注：因为每个节点可以重复到达，所以起点可以到达起点、终点可以到达终点，且起点和终点都为可行点（样例即为例子）。
    注：好像SPFA也可以。
*/

#include<iostream>
#include<cstdio>
#include<cstring>
#include<queue>
#include<list>
using namespace std;

const int MAX=100000+1;
list<int> in[MAX],out[MAX];
char vis[MAX];
int n,m,a[MAX];
int f[MAX],g[MAX];  //f:最小 g:最大
  //f[i] = min{ f[j], a[i] }, G[j][i]=1
  //g[i] = max{ f[j], a[i] }, G[i][j]=1

int main(void){
  scanf("%d%d",&n,&m);
  for(int i=1;i<=n;i++) scanf("%d",&a[i]);
  int x,y,z;
  for(int i=0;i<m;i++){
    scanf("%d%d%d",&x,&y,&z);
    out[x].push_back(y); in[y].push_back(x);
    if(z==2) {in[x].push_back(y); out[y].push_back(x);}
  }

  queue<int> q; list<int>::iterator it;
  //从起点开始bfs，能到达的令其二进制第0位为1
  q.push(1); vis[1]|=1;
  while(!q.empty()){
    int t=q.front(); q.pop();
    for(it=out[t].begin();it!=out[t].end();it++) if(!(vis[*it]&1)){
      vis[*it]|=1;
      q.push(*it);
    }
  }

  while(!q.empty()) q.pop();
  //从终点反向bfs，能反向到达的令其二进制第1位为1
  q.push(n); vis[n]|=2;
  while(!q.empty()){
    int t=q.front(); q.pop();
    for(it=in[t].begin();it!=in[t].end();it++) if(!(vis[*it]&2)){
      vis[*it]|=2;
      q.push(*it);
    }
  }
  
  for(int i=1;i<=n;i++) f[i]=g[i]=a[i];
  for(int i=1;i<=n;i++) if(vis[i]==3){  //可行点的二进制第0、第1位都为1，即十进制的3
    for(it=out[i].begin();it!=out[i].end();it++) f[*it]=min(f[*it],f[i]);
    for(it=in[i].begin();it!=in[i].end();it++) g[*it]=max(g[*it],g[i]);
  }
#ifdef DEBUG
  for(int i=1;i<=n;i++) if(vis[i]==3) printf("  f[%d]: %d, g[%d]: %d\n",i,f[i],i,g[i]);
#endif

  int ansMax=0;
  for(int i=1;i<=n;i++) if(vis[i]==3) ansMax=max(ansMax,g[i]-f[i]); //起点和终点也要考虑在内
  printf("%d\n",ansMax);

  return 0;
}
