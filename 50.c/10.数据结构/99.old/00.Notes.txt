数据结构基础

算法+数据结构=程序

1.概论
问题求解
  问题->数据结构->算法->求解
  农夫过河问题：最短路模型
数据结构与抽象数据类型
  结构=实体+关系
  数据结构：逻辑+存储+运算（三要素）
    按逻辑关系组织的一批数据
    按一定存储方法储存在计算机中
    在数据上定义了一个运算的集合
  数据结构的逻辑组织
    线性结构：
      线性表（顺序表、栈、队列、串等）
      向量
    非线性结构：
      树（二叉树、Huffman树、二叉检索树等）
      图（有向图、无向图等）
    图包含树包含二叉树包含线性表
  数据的存储结构
    逻辑结构到物理存储空间的映射
  计算机主存储器（内存）
    非负整数地址编码，相邻单元的集合
    基本单位为字节
    访问不同地址所需时间基本相同，即随机访问
  对逻辑结构(K,r)，其中r属于R
    对节点K建立一个从K到存储器M的单元映射：K->M，对每一个节点j属于K，都对应一个唯一的连续存储区域c属于M
  四类：顺序、链表、索引、散列
  抽象数据类型(ADT)
    定义了一组运算的数学模型
 <b>与物理存储结构无关</b>
    使软件系统建立在数据之上，即面向对象
  模块化思维
    隐藏运算实现的细节和内部数据结构
    软件复用
  抽象数据结构二元组
    <数据对象D, 数据操作P>
  先定义逻辑结构再定义运算
    逻辑结构：数据对象及其关系
    运算：数据操作
  栈的ADT:
    逻辑结构：线性表
    操作特点：限制访问端口
      只允许在栈顶进行插入、删除操作
      入栈(push)、出栈(pop)、取栈顶(top)、判栈空(isEmpty)
    template<class T>
    class Stack{
    public:
      void clear();            //变为空栈
      bool push(const T item); //成功返回真，否则返回假
      bool pop(T & item);      //
      bool top(T & item);      //
      bool isEmpty();          //若已空返回真
      bool isFull();           //若已满返回假
    };
1.3 算法
  通用性、有效性、确定性、有穷性（操作系统为死循环，不是算法）
  四皇后问题：
    解：<x1,x2,x3,x4>
    搜索空间：4叉树（排列树）
    回溯：大大减少求解时间
  基本算法分类
    1.穷举
      顺序找K值：a[0]设为监视哨，倒序查找，遇到相同则返回，可省略判断下标的一步
    2.回溯（能进则进，不进则换、不换则退）、搜索
      八皇后、树和图的遍历
    3.递归分治
      二分找K值（10个数二分查找，最少1次，最多4次）、快排、归并排序
    4.贪心（最优子结构）
      Huffman编码树、最短路Dijkstra算法、最小生成树Prim算法
    5.动态规划
      最短路Floyd算法
1.4 算法的效率度量
  关注的是增长率
  常数项、低幂次项可忽略
  大O表示法：
    如果存在正数c和n0，使得对任意的n>=n0(n0足够大)，都有f(n)<=cg(n)，则称f(n)在集合O(g(n))中，简称f(n)=O(g(n))
    表示函数增长率的上界
    单位时间 O(1)
      简单bool或算数运算
      简单I/O
        函数的输入/输出
        不包括键盘文件等I/O
      函数返回
    运算规则
      加法规则
        f1(n)+f2(n)=Omax(f1(n),f2(n))
        顺序结构、判断结构
      乘法规则
        f1(n)*f2(n)=O(f1(n)*f2(n))
        循环结构
  大Ω表示法
    如果存在正数c和n0，使得对任意的n>=n0，都有f(n)>=cg(n)，则称f(n)在集合Ω(g(n))中，简称f(n)=Ω(g(n))
    表示函数增长率的下界
  大Θ表示法
    当上界、下界相同时，可用大Θ表示法
    若f(n)=O(g(n))且f(n)=Ω(g(n))，则称f(n)=Θ(g(n))
  二分查找 O(logn)
  时空权衡
    增大空间开销可能改善时间开销
    节省空间通常需要增大时间开销
  数据结构和算法的选择
    问题抽象、数据抽象
      分析问题所涉及的数据类型和数据间的逻辑关系
      数据结构的初步设计往往优先于算法设计
    注意数据结构的可扩展性

面向对象简介
面向对象与流
类与对象
  类是具有相似特征的物体的集合
  对象为类中的特定物体
  对类的操作方法相同
  类->对象：实例化
  变量->构成数据结构
  函数->操作数据结构（抽象）
    变量、函数-捆绑、封装->类
类的定义
  //定义矩形类
  //成员变量：长、宽
  //成员函数：求面积、求周长、设置长宽
  class Rectangle{
    public:  //定义公有成员
      int w,h;
      int Area(){
        return w*h;
      }
      int Permeter(){
        return 2*(w+h);
      }
      void Init(int w_, int h_){
        w=w_; h=h_;
      }
  };  //必须有分号(;)
类的使用
  int main(void){
    int w,h;
    Rectangle r;  //r为矩形类的对象(实例化)
    cin >> w >> h;
    r.Init(w,h);
    cout << r.Area() << endl << r.Permeter() << endl;
    return 0;
  }
  对象名.成员名
  指针->成员名
  引用名.成员名
声明、定义分离
  class Rectangle{
    int w,h;
    int Area();
    int Permeter();
    void Init(int w_, int h_);
  };
  int Rectangle::Area(){  //::表明Area()是Rectangle类的成员函数，而非普通函数
    return w*h;
  }
  int Rectangle::Permeter(){
    return 2*(w+h);
  }
  void Rectangle::Init(int w_, int h_){
    w=w_; h=h_;
  }
访问权限
  class ClassName{
    private:   //私有成员，只能在成员函数中访问
      ...
    public:    //公有成员，可以在任何地方访问
      ...
    protected: //保护成员
      ...
  }
默认函数
class ClassName{
  public:
    ClassName();  //构造函数
    ~ClassName(); //析构函数
    //复制
    ClassName(const ClassName&);
    Classname & operator=(const ClassName&);
    //取地址
    ClassName * operator&();
    const ClassName* operator&() const;
  private:
    ...
};
特殊成员：this指针
  非对象成员，为常量指针
  每个对象可使用this访问自己的地址
  非static成员函数调用时，this指针为隐式指针（使用sizeof()查看大小时，this不计入）
  用途：
    防止自赋值
    返回以连续调用
  class Complex{
    double real, imag;  //默认为private
    public:
      Complex * ReturnAddress(){
        return this;
      }  //c.ReturnAddres <==> &c
      double ReturnReal(){
        return this->real;  //<==> return real;
      }
  }
函数模板
  template<class T>  //模板
  void Print(const T array[], int size){
    for(int i=0;i<size;i++) cout << array[i];
  }
  模板中可以有多个参数
    template<class T1, classT2>
类模板
  template<class T>
  class Carray{
    T * prtElement;
    int size;
    public:
      Carray(int length);
      ~Carray();
      int len();
      void setElement(T arg, int index);
      T getElement(int index);
  };
  使用类模板声明对象
    Carray<int> arrayInt(50), *ptrArrayInt;
    不同模板参数产生的模板类不是同一个类

流
标准输入流
  cin >> x;
  读入整型数时以第一个非数字为终结
  读入字符串时以第一个空格、tab或换行符为终结
  cin.getline(str,len,ch);  //ch被从流中提出，不存入str
                            //ch默认为换行符，可以留空
  ch=cin.get();
  cin.ignore(len,ch);
标准输出流
  cout << y;
  cerr  //输出错误信息
  clog  //输出错误日志
  cout.put('A').put('a');  //输出单个字符，可连用
  流的操纵算子
    头文件 iomanip
    进制：
    int n=10;
    cout << hex << n << endl  //16进制（默认小写字母）
         << dec << n << endl  //10进制输出
         << oct << n << endl; //8进制
    浮点数
      cout << setprecision(6) << x << endl;
      cout << setiosflags(ios::fixed)  //之后都为小数输出
           << setprecision(6) << x << endl
           << y << endl;
    设置域宽
      cin.width(5);  //对一次有效
      cin >> string;
    文件的输入输出
      ifstream fin; ofstream fout;
      fin.open("input"); fout.open("output",ios::out);
      fin >> ...;
      fout << ...;
      打开文件选项
        ios::out  //输出到文件，删除原有内容
        ios::app  //输出到文件，保留原有内容，在末尾添加
        ios::ate  //输出到文件，保留原有内容，可以在文件任意位置添加

针对POJ的调试
  排除编译错误
  程序才执行时卡住无法输出结果，或输出混乱
    对数组和循环做断点+单步跟踪
  测试数据无法通过
    检查算法，插入辅助代码和单步跟踪
    检查变量混淆、数组大小、逻辑错误、初始清零
  测试数据通过，提交后WA
    算法细节疏漏、测试数据不够、次优解
  测试数据通过，提交后RE(Runtime Error)
    数组下标越界、野指针
  ELT
    算法不够优
  WA
    细节
黑盒测试方法
  等价类划分
    1.划分等价类
    2.选择测试用例
  边界分析
    对等价类划分的补充
    尽可能找出边界条件（恰好边界和稍稍超过边界）
  错误推测
  ...

线性表
  简称表
  以零个或多个元素组成的有穷序列
  前驱/后继：ai前面/后面的元素
  直接前驱/后继：与ai相邻的前驱/后继
  有唯一的开始节点，没有前驱，有且只有一个直接后继
  有唯一的终止节点，没有后继，有且只有一个直接前驱
  其他节点为内部节点，每个节点有且只有一个直接前驱、一个直接后继
线性结构
  数据元素之间的相对位置是线性的
  分类
    复杂程度
      简单的：线性表、栈、队列、散列表……
      高级的：广义表、多维数组、文件……
    存储方式
      链表
      顺序表
    访问类型
      直接访问型
      顺序访问型
      目录索引型
    操作：
      线性表
      栈(LIFO)
      队列(FIFO)

线性表
逻辑结构
  长度：预留存储，数据规模
  表头
  表尾
  当前位置

  顺序表
    按索引从小到大的相邻连续区域
    结构结构紧凑，存储密度为1
存储结构
  链式存储或顺序存储
运算
  建立线性表
  清除线性表
  插入元素
  删除元素
  修改元素
  排序
  检索

顺序表
<b>也称向量</b>
  采用一个定长的一维数组存储
链表
  由数据域和指针域组成
  分为单链、双链、循环链
单链表
  带头节点的单链表中的头节点的数据无意义
  单链表中查找任意一个节点都需要从头节点开始
双链表
  更方便地查找前驱
  在p后插入q
    q->prev=p;
    q->next=p->next;
    p->next=q;
    q->next->prev=q;
  删除p
    p->next->prev=p->prev;
    p->prev->next=p->next;
    free(p);
循环链表
<b>tail->next==head</b>
  从任意节点出发都能到其他节点
  结束的判断条件不同

节点的处理
  头指针处理
  非循环链表尾节点的指针域为NULL
  循环链表尾节点的指针指向头节点
链表的处理
  空链表的特殊处理
  插入或删除节点时脂正勾链的顺序
  指针移动的正确性

栈与队列
栈
  实现：顺序栈、链式栈（从栈顶向下链接）
  应用： 表达式求值、消除递归、深搜……
  栈不能读取内部元素，只能读取栈顶元素
队列
  应用：调度或缓冲、广搜……
实指：指针指在最后一个元素
虚指：指针指在最后一个元素之后
循环队列中，使长度为n的队列可以容纳n个元素：
  用front和rear标记队列的头和尾，front、rear实指，用empty表示是否为空，或用len表示元素个数

递归调用原理
  函数调用及返回的步骤
    调用
      1.保存调用信息（参数、返回地址）
      2.分配数据区（局部变量）
      3.将控制转移给被调用函数入口
    返回
      1.保存返回信息
      2.释放数据区
      3.控制转移到上级函数（主调用函数）
递归转非递归
  机械方法：
    1.设置一个工作栈记录当前工作记录
    2.设置t+2个语句标号
    3.增加非递归入口
    4.替换第i(i=1,2,...,t)个递归规则
    5.所有递归出口处增加语句 goto lable t+1;
    6.标号为t+1的语句的格式
    7.改写循环和嵌套中的递归
    8.优化处理

字符串
  以字符集为数据对象
  串长为0的串与" "(空格)不同
  字符编码方式: ASCII, CJK, UNICODE ...
  编码一般遵循“偏序编码规则”
  字符偏序：根据字符的自然含义，比较次序
    大多为字典序
    中文有笔划序
  子串
    空串为任意串的子串，任意串都为空串的主串
    任意串是其自身的子串
    真子串：非空且不为自身的子串
  char * strstr(char * str1, char * str2);  //求子串
  char * strchr(char * str, char c);  //求c第一次出现的位置

int strcmp(char * s1, char * s2){
  int i;
  for(i=0;s1[i]==s2[i];i++)
    if(s1[i]=='\0' && s2[i]=='\0') return 0;
  return ((s1[i]-s2[i])>1 ? 1 : -1);
}

String::String(char * s){  //构造函数
  size=strlen(s);  //计算s长度
  str=new char [size+1];  //开辟新空间用于存储s
  assert(str!=NULL);  //若开辟不成功，运行异常，退出
  strcpy(str,s);
}
String String::operator=(String & s){  //赋值函数
  if(size!=s.size){
    delefe [] str;
    str=new char [s.size+1];
    assert(str!=NULL);
    size=size;
  }
  return * this;
}

模式匹配
  目标串T
  模式P
  寻找配串
[1]朴素算法
  枚举法 O(mn)
  回溯
[2]KMP算法
  无回溯 O(n+m) + O(nm)(预处理N向量)
  若P.substr(1,j-1) == T.substr(i-j+1,j-1)
  但p[j]!=t[i]
  则用p[k]与t[i]重新比较
    显然k<j，且对不同的j，k不同
    k仅以赖于P本身，与T无关
  字符串的特征向量N
    设模式P[0:m-1]由m个字符组成
    令特征向量N(next)用来表示P的字符分布特征，简称N向量由m个特征数n[0]~n[m-1]组成
    构造方法：
      next[j]=-1 ,j=0
              max(p[0:k-1]=p[j-k:j-1], 0<k<j) ,首位配串最长,k最大
              0 ,其他
int findNext(string P){
  int j,k;
  int m=P.length();
  assert(m>0);  //若m==0，退出
  int *next=new int[m];
  assert(next!=0);  //开辟新空间失败，则退出
  next[0]=-1;
  j=0; k=-1;
  while(j<m-1){
    while(k>=0 && P[k]!=P[j]) k=next[k];  //不等则采用KMP自找首位子串
    j++; k++;
    if(P[k]==P[j]) next[j]=next[k];
    else next[j]=k;
  }
  return next;
}

int KMPStrMatching(string T, string P, int * N, int start){
  int j=0,i=start;
  int pLen=P.length(), tLen=T.length();
  if(tLen-start<pLen) return -1;
  while(j<pLen && i<tLen){
    if(j==-1 || T[i]==P[j]) i++, j++;
    else j=N[j];
  }
  if(j>=pLen) return i-pLen;
  else return -1;
}

树
  树是包含至少一个定点的有限集合
  树根
  一个节点的子树数目称为度
  度为0的节点称为叶节点（叶子、终端节点）
  度不为0的节点称为非终端节点
  树的度：树中度最大的节点的度
  X节点的子节点称为X的孩子，X为其父亲
  同一个父亲的各孩子称为兄弟
二叉树
  度不大于2的树，但节点数可以为0
  左右子树有序
  层数
    根为第0层，其他节点层数=父节点层数+1
  深度：层数最大的叶节点的层数
  高度：深度+1
  满二叉树
    除叶节点外，任何节点都有两个子节点的树
  完全二叉树
  扩充二叉树
性质（设根节点为第0层）
  1.在二叉树中，第i层上最多有2^i个节点
  2.深度为k的二叉树最多有2^(k+1)-1个节点
  3.一颗二叉树，若终端节点数为n0，度为2的节点数为n2，则n0=n2+1
    证明：设总节点数为n，度为1的节点数为n1，则n=n0+n1+n2
          设总分支数为B，则B=n-1=2n2+n1
          所以n0=n2+1
  4.满二叉树定理：非空满二叉树树叶数目等于其分支节点数+1
  5.满二叉树定理推论：一个非空二叉树的空子树数目等于其分支节点数+1
  6.有n个节点的完全二叉树的高度为ceil(log2(n+1))
遍历二叉树 O(n)
  空间复杂度： 最好 O(logn) 最差 O(n)
  也是二叉树节点的线性化
  深搜
    按照访问根节点的次序
    前序遍历(tLR)
      访问根节点
      按前序遍历左子树
      按前序遍历右子树
    中序遍历(LtR)
      按中序遍历左子树
      访问根节点
      按中序遍历右子树
    后序遍历(LRt)
      按后序遍历左子树
      按后序遍历右子树
      访问根节点
       A
      / \
     B   C
    / \   \
   D   E   F
      /   / \
     G   H   I
树的线性表示（对应前序遍历）:(A(B(D,E(G)),C(F(H,I))))
前序遍历： A B D E G C F H I
中序遍历： D B G E A C H F I
后序遍历： D G E B H I F C A

表达式二叉树
         -
       /   \
      +     *
     / \   / \
    *   c a   +
   / \       / \
  a   b     b   c
前序遍历(前缀): - + * a b c * a + b c
中序遍历:       a * b + c - a * b + c
后序遍历(后缀): a b * c + a b c + * -
  中缀遍历与原表达式不等价

广搜遍历

二叉树的存储结构
  链表
    二叉链
      left  info  right
    三叉链
    left  info  parent  right
完全二叉树的存储结构
  顺序存储

二叉搜索树（BST）
  可以是一颗空树
  或具有以下性质的二叉树
    若对于任何一个节点，设其值为k
      则该节点的左子树（若非空）的任何一个节点的值都小于k
      且该节点的右子树（若非空）的任何一个节点的值都大于k
    一个节点的左右子树也为BST
  中序遍历是正序的（及升序）
  检索
    只需检索两个子树之一，直到k被找到。若遇到子叶任无法找到，则不存在
  插入
    先检索，若找到则不能插入（BST的关键码一般不重复）
    若找不到，则在该位置插入一个新的叶节点，以此保持BST的性质和性能
  删除
    先检索待删除的节点，找到后，如果该节点仅有一颗子树，则用子树直接取代该节点
    如果有两个子树，则在右子树中寻找最小的节点i，用i的值替换该节点的值，并删除i
总结
  组织内存索引
    BST是适用于内存储器的一种重要树形索引，常用的变种有红黑树、伸展树等，以维持平衡
    在外存中常用B/B+树
  为保持性能，要保证操作后仍符合BST定义，且高度尽量小
  防止BST退化为线性结构

堆与优先队列
堆
  是一个完全二叉树、一个关键码<b>序列</b>
  最小堆：
    一个节点的的两个子节点的值都不小于该节点，及 ki<=k(2i+1) && ki<=k(2i+1)
  性质：
    完全二叉树的层次序列可以用数组表示
    堆中存储的数是局部有序的，堆不唯一
      一个节点的值与其左右子节点的值间存在限制
      但任何一个节点与其兄弟节点之间无直接限制
    从逻辑角度看，堆实际上是树形结构
  SiftDown(int i)
    先将节点i的值n储存，然后对该节点的左右子节点，找到小于n且最小的节点的值替换n，然后进入该节点，继续查找，直到某个节点的子节点的值都大于n或进入叶节点，然后将当前节点的值赋为n
  SiftUp(int i)
    将该节点i的值n存储，检索父节点，并将父节点的值赋给当前节点，直到n大于父节点，最后将当前节点赋为n
  建立最小堆 O(n)
    将n个关键码放入数组中
      整体不是最小堆，但所有<b>叶节点</b>本身是最小堆（只有一个根的堆），即当i>=floor(n/2)时，以关键码ki为根的子树已经是堆
    从倒数第二层，即i=floor(n/2)-1开始，从右往左依次SiftDown，直到i=0，整个完全二叉树成为堆
  删除节点i O(logn) //i为任意节点
    用最后一个节点替换节点i，然后SiftUp(i)或SiftDown(i)
  插入节点i O(logn)
  应用：
    实现优先队列

//从1开始编号，共有tail个元素的最小堆
void SiftDown(int i){
  int k=a[i],j=i<<1;
  while(j<tail){
    if(j+1<tail && a[j+1]<a[j]) j++;
    if(a[j]>k) break;
    a[i]=a[j]; i=j; j<<=1;
  }
  a[i]=k;
}
void SiftUp(int i){
  int k=a[i],j=i>>1;
  while(j && a[j]>k){
    a[i]=a[j]; i=j; j>>=1;
  }
  a[i]=k;
}

Huffman树
  计算机二进制编码
    ASCII编码
    中文编码
  等长编码
    假设所有编码等长，则表示n个不同的字符需要ceil(log_2(n))位
    字符频率相等
  可以依据字符出现的频率编码，频率高的长度小，频率低的长度大
  数据压缩既能节省磁盘空间，又能提高运算速度（外存时空权衡的规则）
  前缀编码
    任何一个字符的编码都不是另一个字符编码的前缀
    保证了代码串被反编码时只会有一种可能

      306
    0/   \1
   120    186  (权)
    E   0/   \1
       79    107
     0/  \1  0/  \1
    37   42  42   65
    U    D   L  0/  \1
               32    33
               C   0/  \1
                   9    24
                 0/ \1  M
                 2   7
                 Z   K

      前缀编码树（规定左为0，右为1）
    对于000110，可以翻译出唯一字符串"EEEL"
    若不用此编码树，将编码改为Z(00), K(01), F(11), C(0), U(1), D(10), L(110), E(010)，则000110对应"ZKE","CCCUUC"等多种可能
  Huffman编码将代码与字符相联系
    不等长编码
    编码长度取决于对应字符的相对使用频率或“权”
  建立Huffman编码树
    对于n个字符K0,K1,...,Kn-1,其对应使用频率分别为w0,w1,...,wn-1,则给出一个具有n个叶节点的扩充二叉树
    且该二叉树每个外部节点ki有一个权wi，外部路径长为li
    叶节点带权的外部路径长度总和为sum(wi*li, i属于[0,n-1])
    权越大的叶节点离根越近
    方法：贪心
      先按照权将字符升序排列
      取前两个节点（即权最小的两个节点），将其标记为Huffman树的子叶，再将其标为一个分支节点的两个孩子，而该节点的权即为两树叶的权之和
      将所得的节点的权放回序列，使权的顺序保持升序
      重复上述步骤直到序列处理完毕
HuffmanTree是正则二叉树，即每个节点的度要么是叶子节点，要么有两个孩子

树
  有且只有一个特定的节点，称为根
  除根以外，其他节点被分成 m 个不相交的有限集合，而每个集合又都是树，称为子树
  有向有序树：子树的相对次序重要
  度为二的有序树不是二叉树
    有序树的第一个节点被删除后，第二子节点自然顶替称为第一；而二叉树的左子树被删除后，右子树仍为右子树
树的逻辑结构
  包含了 n 个节点的有序集合 K ，且在 K 上定义了一个关系 r ，满足：
    1.有且只有一个节点 k0 属于 k ，它对于 r 来说没有前驱，称为树的根
    2.除节点 k0 外， K 中的每个节点对于 r ，有且只有一个前驱
         A
       /   \
      B     C
    / | \  / \
   D  E  F G  H
     / \
    I   J

    节点集合 K = {A, B, C, D, E, F, G, H, I, J}
    K 上的关系 r = {<A,B>, <A,C>, <B,D>, <B,E>, <B,F>, <C,G>, <C,H>, <E,I>, <E,J>}
    // < , > 表示有方向
树的表示
[1]树形表示
       A
     /   \
    B     C
  / | \  / \
 D  E  F G  H
   / \
  I   J

[2]形式语言表示
  节点集合 K = {A, B, C, D, E, F, G, H, I, J}
  K 上的关系 r = {<A,B>, <A,C>, <B,D>, <B,E>, <B,F>, <C,G>, <C,H>, <E,I>, <E,J>}

[3]文氏图表示
+-----------------------------------------+
|                    A                    |
|  +--------------------+    +---------+  |
|  | B   +--------+     |    |    C    |  |
|  |     |   E    |     |    |         |  |
|  | +-+ |+-+ +-+ | +-+ |    | +-+ +-+ |  |
|  | |D| ||I| |J| | |F| |    | |G| |H| |  |
|  | +-+ |+-+ +-+ | +-+ |    | +-+ +-+ |  |
|  |     +--------+     |    |         |  |
|  +--------------------+    +---------+  |
+-----------------------------------------+

[4]凹入表表示
|A
|--B
|  |--D
|  |--E
|  |  |--I
|  |  |--J
|  |--F
|--C
|  |--G
|  |--H

[5]嵌套括号表示
  (A(B(D)(E(I)(J))(F))(C(G)(H)))

森林
  零棵或多棵不相交的树的集合（通常有序）
  树与森林的对应
    一棵树，删除树根，其子树转化为森林
    加入一个节点作为根，森林转化为一棵树
  森林与二叉树之间可以相互转化，而这种转化是一一对应的
  方法（递归）
  森林的遍历：
    先根遍历：先访问该节点，再访问其子节点
    后根遍历：先访问其子节点，再访问该节点
  森林的广度优先遍历：
    不同于二叉树的 BFS ，非平行，而是类似于 L 型的遍历

父指针表示法：
并查集
  一种特殊的集合，由一些不相交的子集构成
  基本操作：
    find: 查询节点所在集合
    union: 归并两个集合
  重要的抽象数据类型
    用于求解等价类等问题
等价类
  互相等价的元素组成的最大集合，所谓最大，即不存在类以外的元素，与类内部的元素等价
  等价关系
    一个具有 n 个元素的集合 S ，有一个定义在 S 上的 r 个关系的集合 R ，x, y, z 表示 S 中的元素
    若 R 是一个等价关系，当且仅当满足以下条件时：
      1.对于所有的 x，有 (x,x) 属于 R （即关系是自反的）
      2.当且仅当 (x,y) 属于 R 时，有 (y,x) 属于 R （即关系是对称的）
      3.若 (x,y) 属于 R ，且 (y,z)属于R ，则 (x,z) 属于 R （即关系是传递的）
    如果 (x,y) 属于 R ，则元素 x 和元素 y 是等价的
  用树表示等价类的并查
    用一棵树代表一个集合
      集合用父节点代替
      若两个节点除现在同一棵树中，则他们处于同一集合
    树的实现
      存储在静态指针数组中，节点只需保存父指针信息
    等价对的合并
      使用加权合并规则，即元素少的树合并为元素多的树的子树
    路径压缩(FindPC)
      Node * findPC(Node * root){
        if(root->parent==NULL) return node;
        root->parent = (findPC(root->parent));
        return root->parent;
      }
      产生极浅树
      使 find 的开销接近于常数
      对 n 个节点进行 n 次 find 操作的开销为 O(na(n))，约为 Θ(nlog*n)
        a(n) 是单变量 Ackermann 函数的逆，其为一个增长速度比 logn 慢得多，但又不是常数的函数
        log*n 是在 n=logn <=1 之前进行的对 n 取对数的操作的<b>次数</b>
        log*65536 == 4
      find 至多需要一系列 n 个 find 操作的开销非常接近于 Θ(n)，在实际应用中，a(n)往往小于4

树的顺序存储结构
  带右链的先根次序表示
    节点按先根次序顺序连续表示
      ltag  info  rlink
        itag: 标记，树的节点没有子节点（即二叉树节点没有左子节点），为 1，否则为 0
        info: 节点数据
        rlink: 指向节点的右兄弟
    利用栈恢复结构
  带双标记的先根次序表示
    带右链的先根次序表示中，rlink 有冗余，可将 rlink 替换为一个标志位 rtag，成为带双标记的先根次序表示
      ltag  info  rtag
        ltag: 有子节点为 0，没有为 1
        rtag: 有右兄弟为 0，没有为 1
  带双标记的层次次序表示
    节点按层次顺序存储
    利用队列恢复结构
  带度数的后跟次序表示
    info  degree
      degree: 节点的度数
    利用栈恢复结构

图
  完全图：每个节点之间都有边的图
  稀疏图、密集图
  无向图、有向图
  带权图
  顶点的度
    无向图
    有向图：入度、出度
  子图
  无环图  
    有向无环图（DAG）
      树和森林是DAG的特例
  回路
    无向图：三个顶点及以上
    有向图：两个顶点及以上
  有根图
  连通图
    无向图的最大连通子图
    有向图的强连通分量（强连通子图）
      有向图的任意两个节点之间都有路径
  网络
    带权的连通图
图的存储结构
  邻接矩阵、邻接表、十字链表
图的算法需考虑的问题
  支持的图的类别
    有向图、无向图
    有回路的图
    非连通图
    权值为负

图的最短路
单源最短路径
