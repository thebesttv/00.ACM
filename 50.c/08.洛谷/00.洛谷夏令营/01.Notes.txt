Day1 solution
剪纸
  30分，n=1，直接输出m
  60分，直接模拟，最多一百万次
  100分，和gcd一样，O(logn)
寻宝之后
  20分，暴力
  30分，都为a，路径计数 f(i,j)=f(i-1,j)+f(i,j-1) 或 C(n+m-2,n-1)  //一共n+m-2步，其中n-1步是向下的
  70分，dp，从两头往中间走，dp[x1][y1][x2][y2]表示分别走到(x1,y1),(x2,y2)的方案数 O(n^4)
  100分，只记录x1,y1,x2三个状态，y2可以推出来 O(n^3)
T3
  20分，暴力
  40分，k=1，线段树
  60分，k=2，根据之前的一次方和与二次方和，还有新的一次方和，推出二次方和
    sum1,sum2分别表示一次方和，二次方和
    区间[l,r],加x
    sum1=sum1+(r-l+1)*x
    (x+y)^2=x^2+y^2+2xy
    ->sum2=sum2+sum*x*
    k<=10，二项式定理 (a+b)^n = sum{ C(n,k)*a^(n-k)*b^k) | 0<=k<=n}

NOIp中的暴力算法
1.循环嵌套
2.枚举排列
3.枚举全集
  void print_subset(int n, int * A, int cur){
    for(int i=0;i<cur;i++) printf("%d ",A[i]); printf("\n");
    int s = cur ? A[cur-1]+1 : 0;
    for(int i=s;i<n;i++){
      A[cur]=j;
      print_subset(n,A,cur+1);
    }
  }
4.枚举子集 O(3^n)
  二进制枚举  //?
    将最后一个1变为0，并将其之后的0都变为1
    for(int s=sta; s ;s=(s-1)&sta)  //sta为初始子集，空集无法枚举
5.枚举染色
  枚举本质不同的染色方案
  dfs(int now, int used){ //now为现染色的物品，used为染色数
    for(int i=1;i<=used+1;i++){ //枚举颜色
      dfs(now+1,max(used,i));
    }
  }

搜索
1.双向宽搜
2.折半搜索
  类似与dbfs
  将搜索范围变为原先的一半，但进行两次
3.ID
  迭代加深搜索
4.A*

初等数论
整数
1.埃氏筛法 O(nloglogn)
  最普通的筛法
2.线性筛法 O(n)
  维护一个质数表
  对于每个a，从小到大枚举所有质数b，将a*b打上标记，<b>如果a%b==0，停止枚举</b>
  每个合数只会被最小的质因子筛到
    for(i=2;i<=n;i++){
      if(a[i]==0) b[++p]=i; //素数入表
      for(j=1;j<=p && i*b[j]<=n;j++){ //枚举表中每个质数
        a[i*b[j]]=1;
        if(i%b[j]==0) break;
      }
    }
  平均每logn个数中有一个质数
3.辗转相除法 O(logn)
  gcd(a,b) = gcd(a-b,b) = gcd(b,a%b)
  lcm(a,b) = a*b/gcd(a,b)
4.拓展欧几里得  //?
  解方程 ax+by=c
    设a'=b,b'=a%b,a'x'+b'y'=c，一直递归，最终b'=0，则x'=c/a'
    bx'+(a-[a/b]*b)y'=c
    ay'+b(x'-[a/b]y')=c
    void gcd(int a, int b, int c, int & x, int &y, int & p){
      if(!b){
        if(c%a==0) {x=c/a; y=0;}
        ...
      }
      ...
    }
5.二进制算法
  常数较小，更适用于大整数
  记a=(2^i)*x, b=(2^j)*y
  则gcd(a,b)=gcd(x,y)*2^(in(i,j)
  当x,y都为奇数时，设x>=y，则将x-=y，再除去多余的2
  int gcd(int a, int b){
    if(!a || !b) return a^b;  //xor:不进位的加法
    int i=0,j=0;
    while(!(a&1)) a>>=1, i++;
    while(!(b&1)) b>>=1, j++;
    while(a!=b){
      if(a<b) a^=b, b^=a, a^=b; //交换a,b
      a-=b;
      while(!(a&1)) a>>=1;
    }
    return a<<min(i,j);
  }

同余
1.快速幂
2.线性求逆元  //?
  i^(-1) === -[p/i]*(p%i)^(-1)
3.费马小定理  //?
  若p为质数，则 p|a^p-a ，即 a^p 同余 a mod p
  若p为质数且a不是p的倍数，则 a^(p-1) 同余 1 mod p
4.欧拉定理
5.快速求逆元
6.中国剩余定理

积性函数
2.求欧拉函数

gcd是k的倍数的数对个数为(floor(n/k))^2
对两个点(x1,y1),(x2,y2)，以其为端点的线段上的整点个数为gcd(x1-x2,y1-y2)-1（除端点）

排列组合
1.排列
  A(n,m)
2.组合
  C(n,m) = A(n,m)/A(m,m) = n!/((n-m)!*m!)
  C(n,k) = C(n-1,k-1) + C(n-1,k)  //第n个数，选或不选
  C(n,0)+C(n,1)+...+C(n,n) = 2^n
3.二项式定理
  (a+b)^n = sum(C(n,k)*a^k*b(n-k))
4.隔板法
  将n个相同的球放入m个不同的袋子，共有C(n+m-1,m-1)种方案
    令 xi 为第i个盘子中的球的个数，则
      sum{ xi } = n
    再令 yi = xi+1，则
      sum{ yi } = n+m
    又因为yi>=1，也就可以想像成共有n+m个“1”，用m-1个隔板把它隔开，每一种状态对应一种方案，也就有 C(n+m-1,m-1) 种方案。
  将n个不同的球放入m个不同的袋子，共有m^n种方案
    一一查看每个球i，它可以放在任意一个袋子中，即i有m中放法。那么共有n个球，根据乘法原理，就有n^m种方案。
  将n个不同的球放入m个相同的袋子
    因为有盘子可能会空，不容易考虑，就先考虑盘子不空的情况。
    令 f(i,j) 为将前i个不同的球，放入j个相同的袋子，并保证每个袋子中至少有一个球的方案数
    则 f(i,j) = f(i-1,j-1) + f(i-1,j)*j //放在一个新的袋子里，或放在之前的袋子里
    因为可能会有一个或多个盘子是空的，答案即为
      f(n,1) + f(n,2) + ... + f(n,m)
  将n个相同的球放入m个相同的袋子
    因为袋子相同，所以<b>令袋子中的球数单调不递减来防止重复</b>
    那么如果第一个袋子中放了球，那么<b>其后面的袋子中都要放一个球</b>来维持单调特性
        如果第一个袋子中不放球，那么直接考虑后面的袋子
    f(i,j) = f(i-j,j) + f(i,j-1)
    f(0,j)=1
  袋子数相同的要dp

计数原理
1.抽屉原理
2.加法原理
3.乘法原理
4.容斥原理

概率与期望
1.概率的性质
  P(A|B)=P(B|A)*P(A)/P(B) <- P(A|B)*P(B)=P(B|A)*P(A)=P(AB)
2.期望的性质
  E(A+B)=E(A)+E(B)

复杂度分析
1.主定理
  假设一道分治的题目，其复杂度为 f(n)=a*f(n/b)+c*n^d，c*n^d为在本次递归中的复杂度，如 f(n)=2f(n/2)+n, f(1)=0
    若 a<b^d, f(n)=O(n^d)
       a=b^d, f(n)=O(n^d*logn)
       a>b^d, f(n)=O(n^(log_b(a)))

  证明见 主定理.pdf

初赛
  使用带表格草稿纸
  Catlan数列

Day2solution
轰炸
毁灭
  把圆切成若干行，记录左右端点
  因为只在最后询问，可以差分，每次把一段加1，计算最后0的个数 O(m)
    差分：用b数组维护a数组，则 a[l:r]++ <==> b[l]++, b[r+1]--
密码
  使用miller-rabin或费马小定理
  所有数都能表示为 (2x+1)*2^y+1
  把询问按找L降序排序，L变小时...

  筛法：按 x*2^12+1 排序，因为x连续，则每三个有一个3的倍数，每5个有一个5的倍数，每七个有一个7的倍数

字符串
1.模式匹配
  KMP
  int KMP(char * s, char * p){
    int sLen=strlen(s), pLen=strlen(p);
    int * next = new int[pLen];
    getN(p,next);
    int i=0,j=0;
    while(i<sLen && j<pLen){
      if(j==-1 || s[i]==p[j]){
        i++; j++;
      }else{
        j=next[j];
      }
    }
    if(j==pLen) return i-j;
    else return -1;
  }
  void getN(char * p, int * next){
    int pLen=strlen(p);
    next[0]=-1;
    int k=-1,j=0;
    while(j<pLen-1){
      if(k==-1 || p[j]==p[k]){
        j++; k++;
        next[j] = (p[j]==p[k] ? next[k] : k);
      }else{
        k=next[k];
      }
    }
  }
  求循环节：若 n-(next[n]+1) 为n的因子，则答案为 n-(next[n]+1)，否则为n

2.Hash
  for(int i=1;i<=n;i++) h[i]=(h[i-1]*base+s[i])%P;
  for(int i=p[0]=1;i<=n;i++) p[i]=p[i-1]*base%P;  //p[i] = base^i
  s[i:j]的hash值为：h[j]-h[i-1]*p[j-i+1]
  减小碰撞：双哈希
    for(int i=1;i<=n;i++) h1[i]=(h1[i-1]*base+s[i])%P1;
    for(int i=1;i<=n;i++) h2[i]=(h2[i-1]*base+s[i])%P2;
    for(int i=p[0]=1;i<=n;i++) p1[i]=p1[i-1]*base%P1;
    for(int i=p[0]=1;i<=n;i++) p2[i]=p2[i-1]*base%P2;
3.Trie
4.AC自动机

对拍
  win, linux
数据生成器
  注意 srand(time(NULL));
  生成极限数据
    椰子树（菊花图+超长链）、菊花图（卡SPFA）、树/图退化成链等
  常识
    生成树的期望高度为logn
    所有生成的数据结构都会趋向平衡
注意事项
  CCF最终评测在NOI-Linux下进行
  win下换行符为\r\n，linux下字符串换行符为\n
  尽量不要使用gets，使用scanf
  linux有很多关键字，try, next, distance, x1, x2, y1, y2, left, right, link, value
  所有程序在linux下编译测试一次
  线段树空间四倍
  强制在线的题目last_ans初始化为0
  函数内定义的变量尽量初始化
  如果两个int和一个long long相乘，要先int乘long long再乘int
    long long的转换括号一定要写在里面
      ans = ((long long)ans*x)%MOD;
  取模防止负数：加MOD
  并查集初始化
  数组下标不能负数
  位运算优先级很低
  多组数据初始化
  如果关闭流同步，cin不能和scanf混用

并查集
  路径压缩、按秩合并
树结构
  n个节点的树只有n-1条边
  期望高度为logn
  存储方式：vector/链式前向星

树中的位运算
  用数组模拟完树二叉树（从1开始），则节点i的左子树为 i<<1，右子树为 i<<1|1 （左移优先级>按位或）

常见数据结构
1.并查集
  传递性
2.堆
3.树状数组
  操作满足可减性
  lowbit(i) = i&-i
  c[i]: (i-lowbit(i),i]
  前缀和代码（后缀和相反）
    void add(int x, int d){
      for(int i=x;i<=n;i+=i&-i)
        c[i]+=d;
    }
    int sum(int x){
      int ans=0;
      for(int i=x;i>0;i-=i&-i)
        ans+=c[i];
      return ans;
    }
   逆序对：从前往后扫描，每次对于数n，就权值大于n的数的个数，即求后缀和
    void add(int x, int d){
      for(int i=x;i>0;i-=i&-i)
        c[i]+=d;
    }
    int sum(int x){
      int ans=0;
      for(int i=x;i<=0;i+=i&-i)
        ans+=c[i];
      return ans;
    }
    int main(void){
    
    }
4.线段树
  任何操作须满足结合律

基础图论
1.基础知识
  存储方式：邻接矩阵、邻接表、边集数组
  无向图的dfs无横叉边
  二分图：不存在奇环（长度为奇数的环）
  在有向图中，如果a能到达b，b也能到达a，则是强连通的
  强连通分量：有向图的极大连通子图
  双连通：a和b之间有两条互不相交的路径
  DAG：有向无环图
    DAG不一定是树
  竞赛图
2.拓扑排序
3.欧拉回路
  每个边遍历一次
  有向图欧拉回路存在条件：所有点的入度等于出度
  无向图欧拉回路存在条件：所有点的度为偶数
  字典序最小的欧拉回路：在反图上dfs
4.tarjan
5.最短路
  核心：松弛操作
    if(dis[v]>dis[u]+G[u][v])
      dis[v]=dis[u]+G[u][v];
  SPFA
  Dijkstra
  Floyd
  若权值都为1，则可用bfs
  求有向图中一个点的来回最短路：在正反两张图上求单源最短路，再相加
6.判正/负环
  SPFA，检查点入队的次数
7.最小生成树
  消圈算法：在图中不断找环，然后将环中较长边删除
  Kruskal
  Prim
8.最近公共祖先（LCA）
  Tarjan
  倍增算法
    f(i,j):节点i向上跳2^j层的父节点
      f(i,j) = f(f(i,j-1),j-1)
    
贪心
  局部最优
  正确性证明
  
合并果子
  合并树一定是正则二叉树，即每个节点要么是叶子节点，要么有两个孩子
  1.最优合并树中，最小的两个叶节点一定在最深的地方且为兄弟节点
  2.如果把最小的两个叶节点删去，仍为最优合并树
    反证法：
      T是n个叶子节点的最优合并树
      T'为T删去a1,a2后得到n-1个叶子节点的合并树
      T*是与T'同有n-1个节点的最优合并树
      T1为将T*中被删去的a1,a2还原成子节点的<b>合并树</b>
      已知 WT'>WT*
      那么 WT'+Wa1+Wa2>WT*+Wa1+Wa2
      即 WT>WT*，与“T为最优合并树”矛盾，因此证明成立
合并果子（修改版）
  合并代价为两堆果子的最小值
  数学归纳法
  每次合并最大的和最小的，或每次合并最大的两个
  1.证明当n=2时成立
  2.由n-1推到n
蚯蚓
  使用三个队列，分别记录
    还没被切的蚯蚓
    被切的蚯蚓的左边
    被切的蚯蚓的右边
  使用全局变量记录增加长度
  每次取三个队列中最大的切
  可以证明每个队列的单调性
国王游戏
  根据每个人左右手的乘积升序排列
  证明：
    对其中ai,ai+1：
    若ai在ai+1前面：S1=max(a1+a2+...+ai-1/bi, a1+a2+...+ai/bi+1)
    若ai+1在ai前面：S2=max(a1+a2+...+ai-1/bi+1,a1+a2+...+ai+1/bi)
      S1,S2同除(a1+a2+...+ai-1)，得
      S1=max(1/bi, ai/bi+1)
      S2=max(1/bi+1, ai+1/bi)
      因为 1/bi <= ai+1/bi, 1/bi+1 <= ai/bi+1
      所以 S1=ai/bi+1
           S2=ai+1/bi
      由命题得ai<=ai+1，即S1应<=S2，即 ai/bi+1 <= ai+1/bi，即 ai*bi <= ai+1*bi+1
有一个n位的数，删除m位，使得剩下的数最小
  每次删除比下一位大的数，如果非降序了则删除最后一个数
  原理：高位权重大，尽量删除高位
拼数
  把n个数拼起来，求得到数的最大值
  按字典序降序排列即可
  证明
    比较字符串a，b时，若 a+b>b+a，则a在前，否则b在前
三国游戏  //?
  必胜
  求每个人的次优配对的默契值的最大值
有n个事件，每个事件占用一段时间，一段时间只能参加至多一个事件，求最多能参加多少个事件

RMQ:范围最值查询

动态规划
  本质：状态的合并
  最优子结构、无后效性
  常见方法：
    1.填表法
      for(所有状态) for(当前状态的所有前驱状态)
        更新当前状态 f[i][j] = ...
    2.刷表法
      for(所有状态) for(当前状态的所有后继状态)
        更新后继状态 f[i+1][j+1] = ...
    3.记忆化搜索
  常见类型/技巧
    1.倒序dp
      给定一个有向无环图，求从起点走到终点的概率
      dp[u]=sum(dp[v]/tot)  //v:u的出边
    2.区间dp
      方便地按照顺序枚举区间
        for(int l=n;l>=1;l--) for(int r=l;r<=n;r++)
      能量项链
        倍长链构造环
      二维平面n个点，使用面积为s的长宽任意的木板覆盖，求最小木板数

                   +--------+
                   | *   *  |
                   |        |
            +------|--------|---------+
            | *    |        |       * |
      --------------------------------------
        dp[l][r][h]:覆盖底l到第r个点中，高度大于等于h的点所需的木板数
          for(x l:r-1) dp[l][r][h] = min(dp[l][r][h], dp[l][x][h]+dp[x+1][r][h])  //将点分为两半
          //使用一块较低的木板，覆盖高小于等于h2的底层点
          int h2=s/(X[r]-X[l]); //X[i]为点i的x座标
          dp[l][r][h] = min(dp[l][r][h], dp[l][r][h2+1]+1);
    3.状压dp
      当状态是一个集合，可使用状态压缩
      骨牌覆盖
        从上到下dp，记录上一行的状态
        n<<1   在n的二进制后加一个0
        n<<1|1 在n的二进制后加一个1
        void dfs(int now, int x, int y){
          //now比哦是搜到了同一行的第几个格子
          //x表示上一行的状态
          //y表示当前行的状态
          if(now==m+1){
            f[y]+=g[x]; return;
          }
          dfs(now+1,x<<1,y<<1|1);
          if(now<m) dfs(now+1,x<<2|3,y<<2|3);
          dfs(now+1,x<<1|1,y<<1);
        }
      炮兵阵地
        状压上两行，预处理三行的状态
  优化方法
    分析时间、空间复杂度
      空间复杂度：状态种数
      事件复杂度：若不考虑均摊分析，即为状态数*转移复杂度
    1.前缀和优化
      n个数字，从1号数字开始，每一步至少跳k，找出一条路径，使得经过的权值和最大
        f[i]表示走到i的最大权值
        f[i] = a[i], i=1
               max{f[j] | j+k<=i} + a[i]
        f[i]=a[i];
        for(int i=2;i<=k;i++) mx[i]=f[i];
        for(int i=k+1;i<=n;i++){
          f[i]=mx[i-k]+a[i];
          mx[i]=max(mx[i],f[i]);
        }
    2.线段树优化
      利用的不是前缀，且信息不可解
      n个数字（有负数），从1号数字开始，每步跳不超过k，找出一条路径，使得经过的权值和最大
        [1]f[i] = a[i], i=1
                  max{f[j] | i-k<j<i} + a[i]
        [2]单调队列
          dequeue<int> q;
          for(int i=1;i<=n;i++){
            while(!q.empty() && a[q.back()]<=a[i]) q.pop_back();
            q.push_back(i);
            if(q.front()<i-k) q.pop_front();
          }
    3.滚动数组优化
      优化空间复杂度
      具有明显的层/阶段的dp，且每个状态
      [1]对层数+1取膜
        数塔问题
          f[i%2][j]=max(f[(i-1)%2][j],f[(i-1)%2][j-1]);
      [2]使用一个新的数组（D1T2）
        使用f,g两个数组，每次将上一层的信息复制到g中，使用f存储新的信息，每次从g转移到f
    4.矩阵优化
      如果转移是一个不依赖于当前位置的线性转移，可以使用矩阵优化
      ...
    5.分治决策（新科技）  //??
      转移最终使用的dp值称为转移的决策
      条件：决策具有单调性
        f[i] = max{...f[j]... | j<i}
        若f[i]由j而来，则j是i的决策
        若对于i<j，满足h[i]<=h[j]
      把n个数字分成k段，使得平方和最小
        //f[i][j]:将前i个数字，分成j段的最小平方和
        f[0][0]=0;
        for(int j=1;j<=k;j++) for(int i=1;i<=n;i++)
          for(int x=1;x<i;x++) dp[i][j]=min(dp[x][j-1]+(sum[i]-sum[x])*(sum[i]-sum[x]);
        //滚动数组
        f[0][0]=0;
        for(int j=1;j<=k;j++){
          memcpy(g,f,sizeof(f));
          memset(f,0x3f,sizeof(f));
          for(int i=1;i<=n;i++) for(int x=1;x<i;x++)
            f[i]=min(f[i],g[x]+(sum[i]-sum[x])*(sum[i]-sum[x]));
        }
        //分治决策
        f[0]=0;
        void solve(int l, int r, int L, int R){ //求从[l,r]所有f值，在合法决策区间[L,R]中求
          if(l>r || L>R) return;
          int m=l+r>>1;
          int where,value=INF;
          for(int i=L,i<+R && i<m;i++){
            if(g[i]+(sum[m]-sum[i])*(sum[m]-sum[i])<value){
              value=g[i]+(sum[m]-sum[i])*(sum[m]-sum[i]);
              where=i;
            }
          }
          f[m]=value;
          solve(l,m-1,L,where); solve(m+1,r,where,R);
        }
        for(int j=1;j<=k;j++){
          memcpy(g,f,sizeof(f)); memset(f,0x3f,sizeof(f));
          solve(1,n,1,n);
        }

图的最长路
  给定一个有向无环图，求图的最长路
  [1]记忆化搜索
  [2]拓扑排序后dp

飞扬的小鸟
  向上完全背包，向下01背包

NOIp技巧
  1.二分
    二分答案：将最优化问题转化为判定性问题
    n个数字，分成相邻的k组，使得每组数字之和的最大值最小
      二分最大值ans，使得每组的值都小于ans，贪心，若组数<=k则可以
      单调性：若满足ans<=x，则也满足ans<=x+1
  2.倍增
    思想：预处理倍增数组+二进制分解
      O(n) -> O(logn)
    快速幂
    ST表（稀疏表）
    求LCA
  3.分块 O(sqrt(n))
    将序列分为sqrt(n)块，每块长度sqrt(n)
    区间加，将操作的区间分成至多sqrt(n)块，以及至多2sqrt(n)的零散元素
    打标记
    LCT(link cut tree)

莫队算法
  ...
