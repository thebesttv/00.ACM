/*
题目描述
公元五八〇一年，地球居民迁至金牛座α第二行星，在那里发表银河联邦创立宣言，同年改元为宇宙历元年，并开始向银河系深处拓展。
宇宙历七九九年，银河系的两大军事集团在巴米利恩星域爆发战争。泰山压顶集团派宇宙舰队司令莱因哈特率领十万余艘战舰出征，气吞山河集团点名将杨威利组织麾下三万艘战舰迎敌。
杨威利擅长排兵布阵，巧妙运用各种战术屡次以少胜多，难免恣生骄气。在这次决战中，他将巴米利恩星域战场划分成30000列，每列依次编号为1,2,...,30000。之后，他把自己的战舰也依次编号为1,2,...,30000，让第i号战舰处于第i列(i=1,2,...,30000)，形成“一字长蛇阵”，诱敌深入。这是初始阵形。当进犯之敌到达时，杨威利会多次发布合并指令，将大部分战舰集中在某几列上，实施密集攻击。
合并指令为 M i j ，含义为第i号战舰所在的整个战舰队列，作为一个整体（头在前尾在后）接至第j号战舰所在的战舰队列的尾部。显然战舰队列是由处于同一列的一个或多个战舰组成的。合并指令的执行结果会使队列增大。
然而，老谋深算的莱因哈特早已在战略上取得了主动。在交战中，他可以通过庞大的情报网络随时监听杨威利的舰队调动指令。在杨威利发布指令调动舰队的同时，莱因哈特为了及时了解当前杨威利的战舰分布情况，也会发出一些询问指令： C i j 。该指令意思是，询问电脑，杨威利的第i号战舰与第j号战舰当前是否在同一列中，如果在同一列中，那么它们之间布置有多少战舰。
作为一个资深的高级程序设计员，你被要求编写程序分析杨威利的指令，以及回答莱因哈特的询问。
最终的决战已经展开，银河的历史又翻过了一页……

输入输出格式
输入格式：
输入文件galaxy.in的第一行有一个整数T（1<=T<=500,000），表示总共有T条指令。
以下有T行，每行有一条指令。指令有两种格式：
M i j ：i和j是两个整数（1<=i, j<=30000），表示指令涉及的战舰编号。该指令是莱因哈特窃听到的杨威利发布的舰队调动指令，并且保证第i号战舰与第j号战舰不在同一列。
C i j ：i和j是两个整数（1<=i, j<=30000），表示指令涉及的战舰编号。该指令是莱因哈特发布的询问指令。

输出格式：
输出文件为galaxy.out。你的程序应当依次对输入的每一条指令进行分析和处理：
如果是杨威利发布的舰队调动指令，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；
如果是莱因哈特发布的询问指令，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 i 号战舰与第 j 号战舰之间布置的战舰数目。如果第 i 号战舰与第 j 号战舰当前不在同一列上，则输出-1。

输入输出样例
输入样例#1：
4
M 2 3
C 1 2
M 2 4
C 4 2

输出样例#1：
-1
1

样例说明：

  1 2 3 4

->M 2 3

  1 3 4
    2

->M 2 4

  1 4
    3
    2
*/

/*
  解题报告：
    并查集的应用。
    令l[i]表示节点i到其根节点（即排在第一个的战舰）的距离（非隔开的个数），p[i]为负时，表示i为根节点，abs(p[i])表示p[i]的节点个数（即当前列的飞船个数）
    在查找时依旧要路径压缩，且在递归改变p[i]前要先将其记录，在递归完成后再更新l[i]。
    在合并时只能将x接到y的后面，且之前要更新l[px]。（只需更新l[px]，对其子树的更新会在之后查找时顺带完成）
*/

#include<iostream>
#include<cstdio>
#include<cstring>
#include<cmath>
using namespace std;

const int MAX=30020;
int p[MAX],l[MAX];  //l[i]: 第i号战舰到p[i]的距离

int find(int x){
  if(p[x]<0) return x;
  int t=p[x];
  p[x]=find(p[x]);
  l[x]+=l[t];
  return p[x];
}
void merge(int x, int y){ //将x接到y后面
  int px=find(x),py=find(y);
  l[px]=-p[py];
  p[py]+=p[px];
  p[px]=py;
}

int main(void){
  memset(p,-1,sizeof(p));
  int m; scanf("%d",&m);
  int type,x,y;
  for(int i=0;i<m;i++){
    do type=getchar(); while(!isalpha(type));
    scanf("%d%d",&x,&y);
    if(type=='M') merge(x,y);
    else{
      int px=find(x),py=find(y);
      int ans;
      if(x==y) ans=0;
      else if(px!=py) ans=-1;
      else ans=(int)abs(l[x]-l[y])-1;
      printf("%d\n",ans);
    }
  }

  return 0;
}
