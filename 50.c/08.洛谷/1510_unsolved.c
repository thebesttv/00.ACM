/*
题目描述
本题为改编题。

问题描述
发鸠之山，其上多柘木。有鸟焉，其状如乌，文首，白喙，赤足，名曰精卫，其名自詨。是炎帝之少女，名曰女娃。女娃游于东海，溺而不返，故为精卫。常衔西山之木石，以堙于东海。——《山海经》
精卫终于快把东海填平了！只剩下了最后的一小片区域了。同时，西山上的木石也已经不多了。精卫能把东海填平吗？
事实上，东海未填平的区域还需要体积为v的木石才可以填平，而西山上的木石还剩下n块，每块的体积和把它衔到东海需要的体力分别为k和m。精卫已经填海填了这么长时间了，她也很累了，她还剩下的体力为c。

输入输出格式
输入格式：
输入文件的第一行是三个整数：v、n、c。
从第二行到第n+1行分别为每块木石的体积和把它衔到东海需要的体力。

输出格式：
输出文件只有一行，如果精卫能把东海填平，则输出她把东海填平后剩下的最大的体力，否则输出’Impossible’（不带引号）。

输入输出样例
输入样例#1:
100 2 10
50 5
50 5

输出样例#1:
0

输入样例#2:
10 2 1
50 5
10 2

输出样例#2:
Impossible

数据范围
对于20%的数据，0<n<=50。
对于50%的数据，0<n<=1000。
对于100%的数据，0<n<=10000，所有读入的数均属于[0,10000]，最后结果<=c。
*/

#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;

const int INF=1<<28;
int f[100020];  //f[i]: 剩余体积为i时的最小体力消耗

int main(void){
  int v,n,c; scanf("%d%d%d",&v,&n,&c);
  for(int i=1;i<=v;i++) f[i]=INF;
  for(int i=1;i<=n;i++){
    int k,m; scanf("%d%d",&k,&m);
    for(int j=v;j>=k;j--){
      f[j]=min(f[j],(f[j-k]>=INF ? 0 : f[j-k])+m);
    }
  }
  if(f[v]>c) printf("Impossible\n");
  else printf("%d\n",c-f[v]);

  return 0;
}
