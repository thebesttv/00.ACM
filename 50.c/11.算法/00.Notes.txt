算法基础

枚举
  给出解空间，建立简洁的数学模型
  减少搜索空间
  采用合适的搜索顺序
  对n个元素两两遍历：
    for(int i=0;i<n-1;i++)
      for(int j=i+1;j<n;j++)

递归
  将问题分成子问题
  子问题与原问题是纵向的、同类的关系
  直接调用：
    fun(){
      fun();
    }
  间接调用：
    fun1(){		fun2(){
      fun2();		  fun1();
    }			}
  递归三要点
    递归式
      将原问题化解为子问题
    递归出口
      即终止条件，最小问题的求解，可以有多个出口
    界函数
      问题规模变化的函数，保证问题规模逐渐向出口条件靠拢
  递归的关键：
    递推公式、终止条件

求阶乘
[1] n!=n*(n-1)*(n-2)*...*1
  int fac=1;
  for(int i=2;i<=n;i++)
    fac*=i;
[2] n!=n*(n-1)!
  int Fac(int n){
    if(n==0) return 1;
    return n*Fac(n-1);
  }

动态规划
  递归函数有n个参数，就定义一个n维数组，数组下标是函数参数的范围，数组元素的值是函数的返回值。这样可以从边界值开始，逐步填充数组，相当于计算递归函数值的逆过程。
  一般思路：
    1.将原问题分解成子问题，子问题一旦求出就保存
    2.确定状态
      和子问题相关的各个变量的一组取值称为一个状态
      某个状态下的值即为某个状态下对应子问题的解
      时间复杂度为状态数目乘计算每个状态所需时间
    3.确定边界状态的值
    4.确定状态转移方程
      即如何从值已知的状态，求出值未知的状态（即“人人为我”递推型）
        数字三角形状态转移方程：
          maxSum[i][j]=D[i][j] ,i==n-1
                       max(maxSum[i+1][j],maxSum[i+1][j+1])+D[i][j] ,i<n-1
    若状态过于简单，无法形成递推关系，则考虑细化状态（增加状态的维度、增加限制条件）
  能用动归解决的问题的特点：
    1.具有最优字结构的性质
      即问题的最优解所包含的子问题的解也是最优的
    2.无后效性
      过程的演变只和状态的值有关，与如何得到值无关
  递归类型
    1.记忆型递归程序
    2.人人为我型
    3.我为人人型

最长公共子序列 O(mn)
  maxLen(i,j): s1左边i个字符与s2左边j个字符的最长公共子序列长度
  maxLen(i,j)=0 ,i==0||j==0
              maxLen(i-1,j-1)+1 ,s1[i-1]==s2[i-1]
              max(maxLen(i,j-1),maxLen(i-1,j)) ,其他

剪枝
  1.选择合适的搜索顺序
    如果一个任务分为多个步骤，从可能性少的步骤开始搜索
      若给定n个大小不等的矩形，判断是否能组成一个大小特定的矩形，则从最大的矩形开始搜索
  2.发现表面不同、实质相同的重复状态，避免重复搜索
  3.从实际问题发掘剪枝方案
种类：
  1.最优化剪枝（通用）
    搜索时记录最优解，如果当前解已经不可能是最优解，则直接返回
  2.可行性剪枝
    及早发现不可能的解

广度优先搜索
  八数码问题：人工智能中的经典问题
    用合理的编码方式表示状态
    [1]将每个状态对应一个九位数，使用一个标志位序列判重，即使用一个二进制位表示是否重复
      可使用一个字符数组存放标志位序列，对每个状态计算其在序列中是第几位
      若某个状态对应数x，则其表示位为a[x/8]的第x%8位
    [2]将每个字符串看作一个9位九进制数
    [3]将每个状态看作0~8的一个排列，以排列在全排列中的位置作为序号，状态用排列的序号表示
      给定排列求序号 O(n^2)
        对于整数 a1,a2,...,ak 的排列，求其序号（从 0 开始排序）
        基本思想：算出有多少个排列比给定排列小
          先算 1 到 a1-1 放在第一位形成的排列个数，即 (a1-1)*((k-1)!)
          再算 a1 不变，1 到 a2-1 放在第二位形成的排列个数（第一位出现的不再使用），即 (a2-1)*((k-2)!)
          再算 a1,a2 不变，1 到 a3-1 放在第三位形成的排列个数，即 (a3-1)*((k-3)!)
          同理计算到 a(k-1)，全部加起来，即为答案
          int convert(int a[], int k){
            int code=0;
            for(int i=0;i<k;i++){
              int cou=0;
              for(int j=i+1;j<k;j++) if(a[j]<a[i]) cou++;
              code+=factorial(k-1-i)*cou;
            }
            return cou;
          }
        给定序号求排列 O(n^2)
          给定序号 n （从 0 开始）和排列长度k，求对应排列
    八数码问题有解性的判定
      八数码问题的状态实际上是 0~8 的一个排列，对于给定排列，不一定有解
        排列分奇排列和偶排列两类，奇排列和偶排列不能互相转换
        排列的奇偶：
          给定 a1, a2, ... a9 的排列，f(x)(x!=0) 表示 a 中在数字 x 之前的比它小的数的个数，f(x) 之和为 y
          若 y 为奇数，则称该排列为奇排列
          若 y 为偶数，则称该排列为偶排列
          因此，可以在搜索前检查初始状态和目标状态的奇偶性是否相同，若相同则可能有解，不同则一定无解
        证明：移动 0 的位置，不改变排列的奇偶性
          设原排列为：
            a1 a2 a3 a4  0 a6 a7 a8 a9
          若 0 向上移动，得：
            a1  0 a3 a4 a2 a6 a7 a8 a9
            1.若 a2<a3 && a2<a4，则 y'=y-2，奇偶性不变
            2.若 a3<a2<a4 || a4<a2<a3，则 y'=y，奇偶性不变
            3.若 a2>a3 && a2>a4，则 y'=y+2，奇偶性不变
          同理可证其他三个方向
    优化方法
      1.双向广搜（DBFS）
        从两个方向使用广搜同时扩展，即从起点和目标节点同时开始扩展，直到一个队列中出现另一个队列的节点，则找到了一条路径
        相比于BFS，搜索树的宽度得到明显减少
            *
           ***
          *****
         -*****-
         --***--
        ----*----
        假设一个节点能扩展出 n 个节点，BFS搜索 m 层能找出答案，则扩展的节点数为 (1-n^m)/(1-n)
        假定对于DBFS，两边各扩展出m/2层，则总节点数目为 2*(1-n^(m/2))*(1-n)
     <b>每次扩展节点总是选择节点数较少的一边进行扩展，并非机械地两边交替</b>
          void dbfs(){
            将起点入队q0，终点入队q1
            当q0,q1都非空时，对节点数较少的队列进行扩展
            如果q0非空，不断扩展q0直到空
            如果q1非空，不断扩展q1直到空
          }
        扩展函数：
          int expand(i){  //i为队列编号，0或1
            取qi队列头h
            对h的每个扩展出的节点nj
              如果nj已在qi中出现过，则抛弃
              否则，将nj入队
                如果nj在q(1-i)中出现过，则输出找到的路径
          }
        定义两个标志序列，分别记录节点是否出现在两个队列中
      2.预处理
        从目标节点开始，做一次彻底的广搜，找出所有可能的解
      3.A*算法

那些朴素的算法思想
1.二分
2.贪心
  仅为某种意义上的局部最优解
  自顶向下的计算，通过贪心选择，将原问题缩小为子问题
  无后效性
