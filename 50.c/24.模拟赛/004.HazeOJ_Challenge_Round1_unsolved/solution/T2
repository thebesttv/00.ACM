简洁版题意：在线支持序列单点插入、历史版本查询 / 还原。

算法一
每次操作暴力复制数组，插入就暴力插入。
时间/空间 复杂度O(n^2)，可以通过子任务1获得25分。

算法二
如果每次只在序列头部插入，我们反向维护一个可持久化数组就可以了。
怎么维护可持久化数组？用可持久化线段树就好啦。关于可持久化线段树，由于不是本题的重点，这里不再赘述。
时间/空间 复杂度 O(nlog⁡)，可以通过子任务2 获得20分。结合算法一可以获得45分。

算法三
如果每次只插入或查询上一次的序列，就不需要可持久化。
这样的话以下标为关键字，用平衡树可以轻松搞定。由于平衡树也不是本题重点，这里不再赘述。
时间复杂度 O(nlogn)，空间复杂度 O(n)，可以通过子任务3获得20分。
结合算法一、二可以获得65分（试问这部分分给得还不够多？？？

算法四
由算法三我们知道，在不需要可持久化的情况下，可以用平衡树轻松维护。现在需要可持久化怎么办？
还能怎么办？可持久化平衡树！
可持久化splay？均摊数据结构就不要想了。本蒟蒻只会写两种：可持久化 treap 和可持久化 AVL，这里主要提下 treap 。
和旋转式 treap 不同，函数式 treap 的所有操作基于 merge/split 两个核心操作。
考虑合并两个 treap merge(a,b)，其中 a 中的元素严格小于 b 中的元素
若a,b其一为空，则返回非空的那个；否则若 priority(a) < priority(b)，将 a 的右孩子和 b 合并作为 a 的右孩子；否则将 a 和 b 的左孩子合并作为 b 的左孩子。
split 操作将一颗 treap 按键值分成两半，具体操作和 merge 相似，留给读者自己思考。
有了merge和split，我们来考虑一些平衡树最常见的操作：
  Insert(pos,v): merge(split1(pos),new_treap(v),split2(r,pos))
  Erase(pos): merge(split1(pos-1),split2(pos))
  find, rank, pre, suc 操作均和旋转式 treap 相同
怎么可持久化呢？只要 merge 和 split 的时候不修改原来的结点，新建结点就可以了。由于 treap 的深度是期望 O(logn) 的，所以每次新建的结点数是期望 O(logn) 的。
时间/空间复杂度 O(nlogn)，可以获得10分。
