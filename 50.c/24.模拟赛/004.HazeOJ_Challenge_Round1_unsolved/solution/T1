简洁版题意：在线支持插入速度曲线和求区间总位移，速度都是多项式函数。
其实这题超级良心的，样例已经暗示了 30~60 分啦！
为方便描述，记mx=所有时刻的最大值。

算法一
n=0时 运动员做匀速直线运动。对 ∀ l≤t0≤t1≤r，其位移为 a0(t1−t0)。
这样的话我们用差分的方式维护答案：维护一个序列 x，操作1给所有 t∈ [l,r] 的 x(t) 加上 a0*t，操作2的答案就是 x(r)−x(l) 。
这样就行了？
当然不行，因为操作1中运动员在 [0,l) 和 (r,mx] 上是没有位移的
Δx((0:l)−1) 应该= Δx(l)=a0*l
Δx(r+(1:mx)) 应该= Δx(r)=a0*r
所以我们还要给 x((0:l)-1) 加上常数 a0l，给 x(r+(1:mx)) 加上常数 a0r 。
到目前为止的分析和方法是本题的基本思路，一定要弄清楚，后面的算法都基于这段分析。
n=0 时 我们要维护的序列 x 是一系列一次函数。对于操作1我们 O(mx) 暴力修改，操作2 O(1) 回答即可。
时间复杂度 O(q⋅mx)，空间复杂度 O(mx)。
可以通过测试点1~3获得15分。
  
算法二
稍有数据结构常识的人都能看出来，这其实就是区间加、单点求值问题。只要用线段树来维护序列 x，操作1和操作2均可以在 O(log⁡mx)时间内解决。当然还有更强的做法，我们将留到算法六。
时间复杂度 O(qlogmx)，空间复杂度 O(mx)。
可以通过 测试点1~3、12~14获得3030分。

算法三
n=1 时运动员做匀加速直线运动。对 ∀ l≤t0≤t1≤r，其位移为 1/2(a1t1 + a0 + a1t0 + a0)*(t1 − t0) = 1/2 * a1t1^2 + a0t1 − (1/2 * a1t0^2 + a0t0)
类似算法一，我们只需要维护一系列二次函数即可。至于1/2怎么处理，相信大家都知道逆元，这里就不赘述了。
时间复杂度 O(q⋅mx)，空间复杂度 O(mx)。
可以通过测试点1~6获得30分。

算法四
类似算法二使用线段树维护二次函数即可。
时间复杂度 O(qlogmx)，空间复杂度 O(mx)。
可以通过 测试点1~6、12~17 获得60分。

算法五
注意到了吗？一个常函数速度的位移可以通过维护一个一次函数得到，一个一次函数速度的位移可以通过一个维护二次函数得到...
于是我们不难想到：一个 n 次函数速度的位移可以通过维护一个 n+1 次函数得到！
这是什么原理？
微积分基本定理：若f(x)=g'(x)，则 ∫(a:b) f(x)dx = g(x)|(a:b) = g(b) − g(a)
其中∫(a:b) f(x)dx 叫作 f(x) 在 [a,b] 上的定积分，表示曲线 f(x) 在 [a,b] 上围成面积的代数和。
初中老师告诉我们，给出 v−t 图像，图像与 x 轴围成的面积就是路程 s 。严格来说应该这样描述：位移是速度在时间上的积分。
（什么？你说我疯了考微积分？我会告诉你这是高中数学课本内容吗？！《高中数学选修2-2 导数及其应用》。你是不是tgz选手？是的话难道高中数学课本超纲？）
我们知道，幂函数的导数(ax^n)' = anx^(n−1) ，所以要将一个多项式函数积分，原函数项 ax^n 的对应项即为 a/(n+1) * x^(n+1)
这就是我们之所以可以用高一次函数的差值维护位移的根本原理。类似算法二，对于一个 n 次速度函数，我们用线段树维护一个 n+1 次多项式即可。
时间复杂度 O(q logmx n)，空间复杂度 O(mn)。
可以通过 测试点11~17获得85分。

算法六
为什么我用线段树只能拿到85分？？？您没看见这题的标签写着 BIT 吗？
认真研究下problem #55，然后您就AC啦！
时间复杂度 O(q logmx n)，空间复杂度 O(mxn)，可以获得100分。
P.S. 实际上可以将时间离散化，所以时间复杂度和mx并没有关系，不过由于是T1，索性就放了10^5。
