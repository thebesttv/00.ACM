简洁版题意：给一棵带点权树，在线支持加边、删边、路径加、路径乘、路径求和。

算法一
每次删边、加边暴力修改邻接表，每次修改、询问暴力遍历整棵树。
时间复杂度 O(qn)，空间复杂度 O(n)，可以通过子任务1获得20分。

算法二
如果树的形态不变，即没有"-"运算的话，这是一道经典的树链剖分题。由于树链剖分不是本题重点，这里不再赘述。
时间复杂度O(n + q(logn)^2)，空间复杂度 O(n)（我相信没人发疯为了一个 log 用 splay 写树剖）。
可以通过子任务22获得30分，结合算法一可以获得50分。

算法三
在树链剖分中，我们定义一个节点 size 最大的孩子为重儿子，重儿子所对的父边为重边，连续的重边构成的路径为重链。
但是，现在树的形态会发生变化，这样的定义显然无所适从。
定义无法套用，思想仍可以借鉴。
定义操作 Access(x) 表示访问 x 到根的路径，一个节点的偏爱子节点是其最后一次被访问时的子节点，它所对应的父边为偏爱边，连续的偏爱边构成的路径为偏爱路径。
用 splay 维护每条偏爱路径，称为 Auxiliary Tree。对于每个点，除了需要维护 father 节点外，还需要额外维护一个 path_parent 表示它上方的偏爱路径的节点，类比树剖里的 top 数组。用 path_parent 将 Auxiliary Trees 连接起来的数据结构，叫做 Link Cut Tree，即LCT。
Access 操作是LCT的基础。出人意料的是，它的操作方式很简单：不断旋转，切断和右子树的连接，再连接新的偏爱子节点。
有了 Access 操作，我们就可以实现几个基本操作：
Makeroot(x) 将 x 换成树根: 访问 x，将 x 旋转到根，反转 x 所在子树；
Link(u,v) 连接u,v: 将 u, v 换成根，设置 v 的 path_parent 为 u ；
Cut(u,v) 删除 u,v 连边：将 u 换成根，访问 v，设置 u,v 的 path_parent 为0
在此基础上进行路径操作就很简单了，对于路径 (u,v) 只要将 u 换成根，再访问 v 就可以得到路径 u,v 的子树，打上两个标记即可。
最后一步太简单懒得写了，如果您不会的话可以研究下 problem #4。（这题是不是应该叫动态树++ =_=
可以证明LCT是均摊 O(logn) 的，证明可以用势能分析，本蒟蒻虽然会证，但实在不想写了。LCT的系统学习可以参考杨哲的论文《QTREE解法的一些研究》。
时间复杂度 O((n+q)logn)，空间复杂度 O(n)，视常数可以通过子任务33~55，可以获得70~100分。
